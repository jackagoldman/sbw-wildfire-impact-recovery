---
title: "Vignette Title"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```



### Subgroup spatial autocorrelation ###

load required packages
```{r}
library(lme4)
library(MuMIn)
library(lmerTest)
library(nlme)
library(sp)
library(gstat)
library(ggplot2)
library(car)
library(rnaturalearth)
library(rnaturalearthdata)
library(viridis)
library(cowplot)
library(spdep)
library(adespatial)

```

```{r}
#check and set working directory
# Function to set appropriate path based on working directory
set_appropriate_path <- function() {
  current_wd <- getwd()
  cat("Current working directory:", current_wd, "\n")
  
  # Check if working directory contains '/goldma34/'
  if (grepl("/goldma34/", current_wd)) {
    base_path <- "/home/goldma34/sbw-wildfire-impact-recovery/"
    cat("Using server path:", base_path, "\n")
  } else {
    # Use current working directory as base
    base_path <- file.path(getwd())
    cat("Using local path:", base_path, "\n")
  }
  
  return(base_path)
}

# Set the base path
base_path <- set_appropriate_path()


#utils
source(file.path(base_path, "src/utils.R"))


# Load your data 
source(file.path(base_path, "src/load_data.R"))

#load
source(file.path(base_path, "src/best_model_functions.R"))

# Load Ontario map data
ontario <- ne_states(country = "Canada", returnclass = "sf") %>%
  filter(name == "Ontario")
```



######################################
# SPATIAL DISTRIBUTION MODELS
######################################
```{r}
# defol dataset - models are for defolaited only fires, make two dataframes for attach residuals and plotting
defol_only_sev <- subset(history_gt90, history == 1)
defol_only_rec <- subset(history_gt90, history == 1)


# window of opportunity subset 1-4
defol_only_sev_1 <- subset(defol_only_sev, window_opp == 1)
defol_only_sev_2 <- subset(defol_only_sev, window_opp == 2)
defol_only_sev_3 <- subset(defol_only_sev, window_opp == 3)
defol_only_sev_4 <- subset(defol_only_sev, window_opp == 4)

```



# Part 1: SEVERITY 


```{r}
# sample sizes for different windows of opportunity
cat("Sample size for Window of Opportunity 1:", nrow(defol_only_sev_1), "\n")
cat("Sample size for Window of Opportunity 2:", nrow(defol_only_sev_2), "\n")
cat("Sample size for Window of Opportunity 3:", nrow(defol_only_sev_3), "\n")
cat("Sample size for Window of Opportunity 4:", nrow(defol_only_sev_4), "\n")


```

## Window of Opportunity 1 


 Define the model formula
 ```{r}
 formula.sev <- rbr_w_offset ~host_pct + Cumulative_Years_Defol + isi_90 + 
  dc_90 + dmc_90 + ffmc_90 + bui_90+ fwi_90 + mean_tri+  x + y 
 ```



MEM as spatial predictor

Create spatial weights

```{r}
# coordinates as matrix
coords_1 <- as.matrix(coordinates(defol_only_sev_1))

# k near neighbor to find max distance for d2
knn1 <- knearneigh(coords_1, k = 2)
nbknn1 <- knn2nb(knn1, sym = TRUE)
# Calculate distances
knn_dists <- nbdists(nbknn1, coords_1)

# Upper threshold (d2)
d2 <- max(unlist(knn_dists))

# Use dnearneigh with the calculated d2
d <- dnearneigh(coords_1, d1 = 0, d2 = d2)

# Create a plot to visualize the neighbors
try({
  plot(d, coords_df, col = "red", main = "Nearest neighbors")
  title(main = paste("Nearest neighbors d=", d2))
}, silent = TRUE)

```


```{r}
# how many disjointed subgraphs
n.comp.nb(d)
```

```{r}
# Create neighbors using different methods
nbtri <- tri2nb(coords_1)
nbgab <- graph2nb(gabrielneigh(coords_1), sym = TRUE)
nbrel <- graph2nb(relativeneigh(coords_1), sym = TRUE)

# Create a plot to visualize the neighbors
# Create a panel of the three neighbor plots
# Remove the try() block to see any errors
par(mfrow = c(1, 3), mar = c(3, 3, 3, 1))  # Increase margin size

# Plot 1: Triangulation neighbors
plot(nbtri, coords_1, col = "red", pch = 20, cex = 0.8)
title(main = "Triangulation", line = 1)
title(sub = paste("Neighbors d =", round(d2, 2)), cex.sub = 0.8, line = 0.5)

# Plot 2: Gabriel neighbors
plot(nbgab, coords_1, col = "blue", pch = 20, cex = 0.8)
title(main = "Gabriel", line = 1)
title(sub = paste("Neighbors d =", round(d2, 2)), cex.sub = 0.8, line = 0.5)

# Plot 3: Relative neighbors
plot(nbrel, coords_1, col = "darkgreen", pch = 20, cex = 0.8)
title(main = "Relative", line = 1)
title(sub = paste("Neighbors d =", round(d2, 2)), cex.sub = 0.8, line = 0.5)

# Reset the layout to default
par(mfrow = c(1, 1))
```

```{r}
# how many disjointed subgraphs
n.comp.nb(nbtri)
n.comp.nb(nbgab)
n.comp.nb(nbrel)
```

```{r}
# define spatial weight matrix
#weight edges between neighbours as a function of spatial distances
distgab <- nbdists(nbgab, coords_1)
fdist <- lapply(distgab, function(x) 1 - x/max(dist(coords_1)))
# Create a listw object
listw_gab <- nb2listw(nbgab, glist = fdist, style = "W", zero.policy = TRUE)
```


```{r}
#Create MEM
mem.gab <- mem(listw_gab)
mem.gab
```

```{r}
# select best mem
selected <- forward.sel(Y = as.data.frame(defol_only_sev_1$rbr_w_offset), X = as.data.frame(mem.gab))
selected_mem <- mem.gab[, selected$order]
# Print selected MEMs
print(selected_mem)
# selecte first MEM
first_mem <- selected_mem[, 1]
# Print selected MEM
print(first_mem)
```

```{r}
# cbind selected MEMs to the original data
defol_only_sev_1 <- cbind(defol_only_sev_1, first_mem)

# LM
# modify formula to include selected MEMs
formula.sev_mem <- update(formula.sev, . ~ . + first_mem)
# remove x and y from the formula
formula.sev_mem <- update(formula.sev_mem, . ~ . - x - y)
# fit the model using LM
model_lm_sev_mem <- lm(formula.sev_mem, data = defol_only_sev_1)
# Display the model summary
mod.sum_sev_mem <- summary(model_lm_sev_mem)
# print
print(mod.sum_sev_mem)
```

```{r}
#check multicollinearity
vif_results <- vif(model_lm_sev_mem)
# Print the VIF results
print(vif_results)
# Identify variables with high VIF
identify_high_vif <- function(model, threshold = 10) {
  vif_values <- vif(model)
  high_vif_vars <- names(vif_values[vif_values > threshold])
  
  if (length(high_vif_vars) > 0) {
    cat("Variables with VIF greater than", threshold, ":\n")
    print(high_vif_vars)
  } else {
    cat("No variables with VIF greater than", threshold, "\n")
  }
  
  return(list(high_vif_vars = high_vif_vars))
}
# Identify variables with high VIF
high_vif_results <- identify_high_vif(model_lm_sev_mem, threshold = 10)

# Get the list of variables with high VIF
high_vif_vars <- high_vif_results$high_vif_vars
# Print the variables with high VIF
print(high_vif_vars)
```

```{r}

```

```{r}
# remove high VIF variables from the model
formula.wo1 <- update(formula.sev_mem, . ~ . - isi_90 - dc_90 - dmc_90  - bui_90 - fwi_90)

#refit the model again without high VIF variables
model_lm_sev_mem_wo1 <- lm(formula.wo1, data = defol_only_sev_1)
# Display the model summary
mod.sum_sev_mem_wo1 <- summary(model_lm_sev_mem_wo1)
# print
print(mod.sum_sev_mem_wo1)
#check multicollinearity
vif_results_wo1 <- vif(model_lm_sev_mem_wo1)
# Print the VIF results
print(vif_results_wo1)
```

```{r}
#get residuals
defol_only_sev_1$residuals_lm_mem <- residuals(model_lm_sev_mem)

## Compute the variogram
variogram_lm_wo1 <- gstat::variogram(residuals_lm_mem ~ 1, data = defol_only_sev_1)

# Plot the variogram
lm_var_plot <- plot(variogram_lm_wo1, main = "Variogram of Residuals (Gaussian)")



# confirm defol_only as dataframe
df.sev_1 <- as.data.frame(defol_only_sev_1)

# Create a spatial plot of residuals with lm
spat.resid.sev_plot_wo1 <- ggplot() +
  geom_sf(data = ontario, fill = "navajowhite1", color = "black") +
  geom_point(data = df.sev_1, aes(x = x, y = y, color = residuals_lm_mem)) +
  scale_color_gradient2(low = "#88CCEEA0", mid = "white", high = "#8B0000A0", midpoint = 0) +
  labs(title = NULL, x = "Longitude", y = "Latitude", color = "Residuals") +
  theme_bw()
```

```{r}
lm_var_plot
```



```{r}
spat.resid.sev_plot_wo1
```